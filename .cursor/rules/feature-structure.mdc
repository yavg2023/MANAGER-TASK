---
alwaysApply: true
---
# Feature Structure Implementation Rule

## Objetivo
Esta rule define el marco de trabajo estándar para implementar features, corregir funcionalidades existentes o solucionar bugs en la aplicación de gestión de tareas. El objetivo es mantener una solución limpia, simple, bien estructurada y libre de errores.

## Directiva de Uso
**Aplicar esta rule siempre** al implementar cualquier cambio en la aplicación, independientemente de si es una feature nueva, corrección o bug fix.

## Principios Fundamentales

### 1. Filosofía de Desarrollo
- **DRY (Don't Repeat Yourself)**: Evitar duplicación de código. Si algo se repite 2+ veces, considerar extracción.
- **KISS (Keep It Simple, Stupid)**: Priorizar soluciones simples sobre complejas. La aplicación es sencilla, no necesita sobre-ingeniería.
- **YAGNI (You Aren't Gonna Need It)**: No implementar funcionalidades que no se necesitan ahora.
- **SRP (Single Responsibility Principle)**: Cada clase/función debe tener una única responsabilidad clara.

### 2. Estructura de Archivos Modular

La aplicación sigue una estructura modular donde los componentes específicos de cada módulo se organizan por directorio de módulo. Los componentes transversales se ubican en los directorios base.

#### 2.1. Estructura Base

```
lib/
├── exceptions/        # Excepciones personalizadas (transversal)
├── models/            # Modelos de datos (estructura por módulo)
│   ├── security/      # Modelos del módulo security
│   ├── tasks/         # Modelos del módulo tasks
│   └── backoffice/    # Modelos del módulo backoffice
├── services/          # Lógica de negocio (estructura por módulo)
│   ├── security/      # Servicios del módulo security
│   ├── tasks/         # Servicios del módulo tasks
│   └── backoffice/    # Servicios del módulo backoffice
├── providers/         # Gestión de estado (estructura por módulo)
│   ├── security/      # Providers del módulo security
│   ├── tasks/         # Providers del módulo tasks
│   └── backoffice/    # Providers del módulo backoffice
├── screens/           # Pantallas completas (estructura por módulo)
│   ├── security/      # Pantallas del módulo security
│   ├── tasks/         # Pantallas del módulo tasks
│   └── backoffice/    # Pantallas del módulo backoffice
├── widgets/           # Widgets reutilizables (estructura por módulo)
│   ├── security/      # Widgets del módulo security
│   ├── tasks/         # Widgets del módulo tasks
│   └── backoffice/    # Widgets del módulo backoffice
├── navigation/        # Configuración de rutas (transversal)
├── theme/             # Temas y estilos (transversal)
└── utils/             # Utilidades (transversal)
```

#### 2.2. Reglas de Organización

**Directorios con estructura modular**:
- `lib/models/`: Crear subdirectorio por módulo solo si el módulo tiene modelos.
- `lib/services/`: Crear subdirectorio por módulo solo si el módulo tiene servicios.
- `lib/providers/`: Crear subdirectorio por módulo solo si el módulo tiene providers.
- `lib/screens/`: Crear subdirectorio por módulo solo si el módulo tiene pantallas.
- `lib/widgets/`: Crear subdirectorio por módulo solo si el widget es específico del módulo.

**Directorios transversales y estructura de excepciones**:
- `lib/navigation/`: Configuración de rutas transversal.
- `lib/theme/`: Temas y estilos transversales.
- `lib/utils/`: Utilidades transversales.
- `lib/screens/`: Pantallas transversales como `home_screen.dart` (router según rol según `app-scope.mdc`) se ubican directamente en `lib/screens/`, sin subdirectorio de módulo.
- `lib/exceptions/`: **Estructura híbrida**:
  - **Excepciones transversales**: Se ubican directamente en `lib/exceptions/` (ej: `app_exception.dart`, `database_exception.dart`).
  - **Excepciones específicas de módulo**: Se organizan en subdirectorios por módulo (ej: `lib/exceptions/tasks/`, `lib/exceptions/security/`).
  - **Criterio**: Si una excepción puede ser usada por múltiples módulos, es transversal. Si es específica de un módulo, va en subdirectorio.

#### 2.3. Ejemplo de Estructura Completa

```
lib/
├── exceptions/
│   ├── app_exception.dart          # Clase base transversal
│   ├── database_exception.dart     # Excepciones de BD (transversal)
│   └── tasks/                      # Excepciones específicas del módulo tasks
│       └── task_exceptions.dart
├── models/
│   ├── security/
│   │   └── user.dart
│   ├── tasks/
│   │   └── task.dart
│   └── backoffice/
│       └── (puede no tener modelos propios, usar Task y User)
├── services/
│   ├── security/
│   │   ├── auth_service.dart
│   │   └── user_service.dart
│   ├── tasks/
│   │   └── task_service.dart
│   └── backoffice/
│       └── admin_task_service.dart
├── providers/
│   ├── security/
│   │   └── auth_provider.dart
│   ├── tasks/
│   │   └── task_provider.dart
│   └── backoffice/
│       └── admin_provider.dart
├── screens/
│   ├── home_screen.dart          # Componente transversal (router según rol)
│   ├── security/
│   │   ├── login_screen.dart
│   │   └── register_screen.dart
│   ├── tasks/
│   │   ├── task_dashboard_screen.dart
│   │   └── task_detail_screen.dart
│   └── backoffice/
│       └── admin_dashboard_screen.dart
├── widgets/
│   ├── security/
│   │   └── login_form.dart
│   ├── tasks/
│   │   ├── task_card.dart
│   │   └── kanban_column.dart
│   └── backoffice/
│       └── task_filter_bar.dart
├── navigation/
│   └── app_router.dart
├── theme/
│   └── app_theme.dart
└── utils/
    ├── logger.dart
    └── validators/
        ├── task_validator.dart
        └── user_validator.dart
```

#### 2.4. Guía de Implementación por Módulo

Cuando se solicite implementar algo para un módulo específico:

**Para módulo `security`**:
- Modelos → `lib/models/security/`
- Servicios → `lib/services/security/`
- Providers → `lib/providers/security/`
- Screens → `lib/screens/security/`
- Widgets → `lib/widgets/security/`

**Para módulo `tasks`**:
- Modelos → `lib/models/tasks/`
- Servicios → `lib/services/tasks/`
- Providers → `lib/providers/tasks/`
- Screens → `lib/screens/tasks/`
- Widgets → `lib/widgets/tasks/`

**Para módulo `backoffice`**:
- Modelos → `lib/models/backoffice/` (solo si tiene modelos propios)
- Servicios → `lib/services/backoffice/`
- Providers → `lib/providers/backoffice/`
- Screens → `lib/screens/backoffice/`
- Widgets → `lib/widgets/backoffice/`

**Componentes transversales**:
- Excepciones → `lib/exceptions/` (sin subdirectorio)
- Navegación → `lib/navigation/` (sin subdirectorio)
- Tema → `lib/theme/` (sin subdirectorio)
- Utilidades → `lib/utils/` (sin subdirectorio, puede tener subdirectorios por tipo solo si agrupan múltiples utilidades: `validators/`, etc. Utilidades individuales van directamente en `lib/utils/`)

### 3. Reglas de Implementación

#### 3.1. Widgets
- **Tamaño**: Idealmente < 200 líneas por widget
- **Responsabilidad**: 1 responsabilidad por widget
- **Reutilización**: Si un widget se usa en 2+ lugares, extraer a `widgets/`
- **Composición**: Preferir composición sobre widgets gigantes

```dart
// ✅ Bien: Widget pequeño y enfocado
class TaskCard extends StatelessWidget {
  final Task task;
  const TaskCard({required this.task, super.key});
  
  @override
  Widget build(BuildContext context) {
    return Card(/* ... */);
  }
}

// ❌ Evitar: Widget gigante con múltiples responsabilidades
```

#### 3.2. Modelos
- **Inmutabilidad**: Usar `const` cuando sea posible, campos `final`
- **Freezed**: Considerar freezed solo si realmente simplifica (no es obligatorio)
- **Serialización**: Siempre implementar `toMap()` y `fromMap()` cuando se persiste

```dart
// ✅ Bien: Modelo inmutable
class Task {
  final int? id;
  final String title;
  final String description;
  final bool completed;
  
  const Task({
    this.id,
    required this.title,
    required this.description,
    this.completed = false,
  });
  
  Map<String, dynamic> toMap() => {/* ... */};
  factory Task.fromMap(Map<String, dynamic> map) => {/* ... */};
}
```

#### 3.3. Null Safety
- **Evitar `!`**: Raramente necesario, preferir manejo explícito
- **Usar `?`**: Cuando el valor puede ser null
- **`required`**: Para parámetros obligatorios
- **`late`**: Solo cuando esté bien justificado (inicialización diferida)

```dart
// ✅ Bien: Null safety explícito
String? getUserName() => _user?.name;
void setUser(User user) => _user = user; // required implícito

// ❌ Evitar: Forzar unwrap sin verificación
String name = user!.name; // Solo si realmente estamos seguros
```

#### 3.4. Async y Manejo de Errores
- **Try-catch**: Siempre capturar errores en operaciones async
- **No ignorar Futures**: Siempre await o manejar adecuadamente
- **Verificación de mounted**: En StatefulWidget, verificar `mounted` antes de setState después de async

```dart
// ✅ Bien: Manejo completo de async
Future<void> loadData() async {
  try {
    _loading = true;
    notifyListeners();
    _data = await _service.fetchData();
    _loading = false;
    notifyListeners();
  } catch (e) {
    _loading = false;
    _handleError(e);
    notifyListeners();
  }
}

// ✅ Bien: Verificación de mounted
void _save() async {
  await _operation();
  if (!mounted) return;
  setState(() => _loading = false);
}
```

#### 3.5. Estructura de Código
- **Clases pequeñas**: Evitar clases/funciones gigantes (> 300 líneas es señal de alerta)
- **Parámetros limitados**: Si una función tiene > 5 parámetros, considerar un objeto de configuración
- **Utils específicos**: Evitar "utils" genéricos con todo mezclado. Mejor: `task_validator.dart`, `date_formatter.dart`, etc.

```dart
// ✅ Bien: Función con pocos parámetros
void updateTask(int id, String title);

// ❌ Evitar: Demasiados parámetros
void updateTask(int id, String title, String desc, bool completed, DateTime date, int priority);
// Mejor: Map<String, dynamic> changes
```

#### 3.6. Observabilidad y Logging
- **Logger centralizado**: Crear una utilidad de logging (`lib/utils/logger.dart`)
- **Logs estratégicos**: Solo donde realmente aporten valor (errores, puntos críticos)
- **No print**: Nunca usar `print()`, siempre usar el logger

```dart
// lib/utils/logger.dart
class AppLogger {
  static void info(String message) => debugPrint('[INFO] $message');
  static void error(String message, [Object? error]) => 
    debugPrint('[ERROR] $message${error != null ? ": $error" : ""}');
}

// Uso
AppLogger.error('Error al cargar tareas', e);
```

#### 3.7. Linting y Formateo
- **Linting estricto**: Activar `flutter_lints` con reglas estrictas
- **Sin warnings**: Todos los warnings deben resolverse (no ignorarlos por defecto)
- **Uso de `ignore`**: Solo usar `// ignore: lint_rule_name` cuando haya una razón técnica válida que impida resolver el warning
  - **Cuándo usar**: Solo para casos borde donde el warning no puede ser resuelto sin cambiar funcionalidad o cuando hay una restricción técnica del lenguaje (ej: interpolación de strings impide usar `const`)
  - **Cuándo NO usar**: Nunca ignorar warnings por conveniencia o pereza. Siempre intentar resolver el warning primero
  - **Documentación obligatoria**: Cuando uses `ignore`, siempre agrega un comentario explicando por qué no se puede resolver el warning
- **Formateo**: Siempre ejecutar `dart format` antes de commitear
- **Nombres claros**: Variables, funciones y clases con nombres descriptivos y consistentes

```dart
// ✅ Bien: Nombres claros
final taskList = _loadTasks();
bool isValid = _validateTask(task);

// ❌ Evitar: Nombres ambiguos
final tl = _lt();
bool v = _v(t);
```

**Ejemplo de uso correcto de `ignore`**:
```dart
// ✅ Bien: Ignorar con razón técnica válida y comentario explicativo
if (trimmed.length > maxTitleLength) {
  // No se puede usar const porque el mensaje usa interpolación de strings ($maxTitleLength)
  // y las expresiones con interpolación no son constantes en tiempo de compilación
  // ignore: prefer_const_constructors
  return ValidationResult(
    isValid: false,
    error: 'El título no puede exceder $maxTitleLength caracteres',
  );
}

// ❌ Evitar: Ignorar sin razón válida o sin comentario
// ignore: prefer_const_constructors
return ValidationResult(isValid: false, error: 'Error');

// ✅ Mejor: Intentar resolver primero
return const ValidationResult(
  isValid: false,
  error: 'Error', // String literal, no interpolación = puede ser const
);
```

#### 3.8. Testing
- **Sin tests**: No se implementan pruebas unitarias, de integración o e2e
- **Testing manual**: El usuario realizará testing manual
- **Verificación básica**: Verificar que compile sin errores y que los linters pasen

### 4. Patrones de Implementación

#### 4.1. Crear Nueva Feature
1. **Identificar módulo**: Determinar a qué módulo pertenece la feature (security, tasks, backoffice).
2. **Modelos** (si aplica): Crear modelos inmutables en `models/{modulo}/`
3. **Servicios**: Implementar lógica de negocio en `services/{modulo}/` **considerando soporte multiplataforma**
4. **Providers**: Agregar estado en `providers/{modulo}/` si es necesario
5. **Screens**: Crear pantallas en `screens/{modulo}/`
6. **Widgets**: Extraer widgets reutilizables a `widgets/{modulo}/` si son específicos del módulo. Widgets transversales van en `widgets/` base.
7. **Navegación**: Agregar rutas en `navigation/app_router.dart` si es nueva pantalla

#### 4.1.1. Consideraciones Multiplataforma en Servicios

**Importante**: La aplicación soporta múltiples plataformas con diferentes sistemas de persistencia:

- **Mobile/Desktop**: Usa SQLite mediante `task_service_io.dart`
- **Web**: Usa SharedPreferences mediante `task_service_web.dart`

**Directiva al implementar servicios**:

1. **Mantener consistencia de modelo**:
   - Ambos servicios deben usar el mismo modelo (`Task`)
   - Campos del modelo deben persistirse en ambas plataformas
   - Cambios en el modelo requieren actualización en ambos servicios

2. **Implementar funcionalidad en ambas plataformas**:
   - Si se agrega método en `task_service_io.dart`, también agregarlo en `task_service_web.dart`
   - Comportamiento debe ser consistente entre plataformas
   - Parámetros y valores de retorno deben ser idénticos

3. **Consideraciones específicas de plataforma**:
   - **SQLite (IO)**: Usar queries SQL, `DatabaseHelper.withDatabase()`, soportar migraciones
   - **SharedPreferences (Web)**: Serializar/deserializar JSON, usar claves específicas, filtrar en memoria si es necesario

4. **Ejemplo de implementación consistente**:
   ```dart
   // task_service_io.dart (SQLite)
   Future<List<Task>> loadTasks({
     String? orderBy,
     String? orderDirection,
     String? titleFilter,
     bool? completedFilter,
   }) async {
     return await DatabaseHelper.withDatabase((db) async {
       // Construir query SQL con WHERE y ORDER BY
       String where = '';
       List<Object?> whereArgs = [];
       // ... construir WHERE clause ...
       final res = await db.query('tasks', where: where, whereArgs: whereArgs, orderBy: orderBy);
       return res.map((r) => Task.fromMap(r)).toList();
     });
   }
   
   // task_service_web.dart (SharedPreferences)
   Future<List<Task>> loadTasks({
     String? orderBy,
     String? orderDirection,
     String? titleFilter,
     bool? completedFilter,
   }) async {
     final prefs = await SharedPreferences.getInstance();
     final tasksJson = prefs.getString(_key) ?? '[]';
     final List<dynamic> tasksList = jsonDecode(tasksJson);
     var tasks = tasksList.map((t) => Task.fromMap(t)).toList();
     
     // Filtrar en memoria
     if (titleFilter != null && titleFilter.isNotEmpty) {
       tasks = tasks.where((t) => t.title.toLowerCase().contains(titleFilter.toLowerCase())).toList();
     }
     if (completedFilter != null) {
       tasks = tasks.where((t) => t.completed == completedFilter).toList();
     }
     
     // Ordenar en memoria
     tasks.sort((a, b) {
       // ... lógica de ordenamiento ...
     });
     
     return tasks;
   }
   ```

5. **Aislamiento por usuario (futuro con módulo security)**:
   - **Web**: Usar claves dinámicas `tasks_user_${userId}_v1` en SharedPreferences
   - **SQLite**: Filtrar con `WHERE userId = ?` en queries
   - Ver `REPORTE-PERSISTENCIA-MULTIPLATAFORMA.md` para detalles completos

#### 4.2. Corregir Funcionalidad
1. Identificar el archivo afectado
2. Verificar dependencias
3. Realizar corrección mínima necesaria
4. Verificar que no rompa otras funcionalidades
5. Ejecutar linters

#### 4.3. Solucionar Bug
1. Reproducir el bug (entender el problema)
2. Identificar la causa raíz
3. Aplicar fix mínimo y específico
4. Verificar que el bug está resuelto
5. Verificar que no introduce nuevos bugs

### 5. Checklist Pre-Commit

Antes de considerar una implementación completa:

- [ ] Código compila sin errores
- [ ] Linter pasa sin warnings (o warnings ignorados solo cuando hay razón técnica válida con comentario explicativo)
- [ ] Código formateado (`dart format`)
- [ ] Nombres de variables/clases/funciones son claros
- [ ] No hay código duplicado innecesario
- [ ] Widgets son pequeños (< 200 líneas ideal)
- [ ] Async code tiene manejo de errores
- [ ] Null safety manejado correctamente (evitar `!`)
- [ ] Verificaciones de `mounted` en StatefulWidget después de async
- [ ] Logging usado donde es necesario (no print)
- [ ] Estructura de archivos respetada

### 6. Estructura de Excepciones

**Jerarquía de Excepciones**:
La aplicación utiliza una jerarquía de excepciones simple que combina excepciones transversales y específicas de módulo:

```
lib/
└── exceptions/
    ├── app_exception.dart          # Clase base abstracta transversal
    ├── tasks/                      # Excepciones específicas del módulo tasks
    │   └── task_exceptions.dart
    │       ├── TaskNotFoundException (extends AppException)
    │       └── TaskValidationException (extends AppException)
    └── security/                   # Excepciones específicas del módulo security (si aplica)
        └── auth_exceptions.dart
```

**Principio de Simplicidad**: No crear clases intermedias innecesarias. Las excepciones específicas de módulo extienden directamente de `AppException`, no de clases base intermedias a menos que realmente aporten valor.

**Reglas de Organización**:
- **`AppException`**: Clase base abstracta transversal en `lib/exceptions/app_exception.dart`. Todas las excepciones personalizadas deben extender de esta clase.
- **Excepciones específicas de módulo**: Se organizan en subdirectorios: `lib/exceptions/{modulo}/`. Extienden directamente de `AppException`, sin clases intermedias innecesarias.
- **Errores de base de datos**: No se crea una `DatabaseException` separada. Los errores de BD pueden envolverse en `AppException` con mensaje descriptivo cuando sea necesario mostrarlo al usuario. Para errores técnicos que solo se registran, usar try-catch con logging.
- **Principio KISS**: Solo crear excepciones personalizadas cuando aporten valor claro (mensajes específicos, distinción de tipos de error). Evitar jerarquías complejas.

**Cuándo crear una excepción personalizada**:
- Cuando necesites proporcionar mensajes de error específicos y en español al usuario.
- Cuando el tipo de error tenga significado de negocio que deba distinguirse (ej: "Tarea no encontrada" vs "Error de validación").
- Para errores de dominio (negocio), no para errores técnicos genéricos que Dart ya maneja bien.
- **Regla práctica**: Si solo vas a tener 1-2 excepciones por módulo, no crear clase base intermedia. Extender directamente de `AppException`.

**Cuándo NO crear una excepción personalizada**:
- Para errores de BD genéricos: envolver en `AppException` con mensaje descriptivo si es necesario mostrarlo al usuario, o usar try-catch con logging si es técnico.
- Para errores que solo se registran: usar logging, no excepción personalizada.
- Cuando una excepción genérica de Dart es suficiente.

**Implementación**:
- Todas las excepciones deben tener un campo `message` y sobrescribir `toString()`.
- Mensajes en español (para el usuario final).
- Evitar excepciones genéricas cuando hay casos específicos.
- Extender de la jerarquía correcta: `AppException` → excepciones específicas directamente, sin clases intermedias innecesarias.

```dart
// ✅ Bien: Estructura simple y directa
abstract class AppException implements Exception {
  final String message;
  AppException(this.message);
  @override
  String toString() => message;
}

// Excepciones específicas extienden directamente de AppException
class TaskNotFoundException extends AppException {
  TaskNotFoundException(int id) : super('Tarea con ID $id no encontrada');
}

class TaskValidationException extends AppException {
  TaskValidationException(String message) : super(message);
}

// Para errores de BD: envolver en AppException si necesita mostrarse al usuario
try {
  await db.insert(...);
} catch (e) {
  throw AppException('No se pudo guardar la tarea. Por favor, intenta nuevamente.');
}
```

**Uso Práctico en Servicios**:
```dart
// ✅ Bien: Validar primero, luego operación con try-catch
Future<Task> createTask(String title, String description) async {
  // Validar antes de intentar crear
  final errors = TaskValidator.validateTask(title: title, description: description);
  if (errors.isNotEmpty) {
    throw TaskValidationException(errors.values.first);
  }
  
  try {
    return await DatabaseHelper.withDatabase((db) async {
      // ... operación de BD
    });
  } catch (e) {
    if (e is AppException) rethrow; // Re-lanzar excepciones personalizadas
    AppLogger.error('Error en BD', e);
    throw AppException('No se pudo crear la tarea. Por favor, intenta nuevamente.');
  }
}

// ✅ Bien: Usar TaskNotFoundException cuando no existe
Future<Task?> updateTask(int id, Map<String, dynamic> changes) async {
  try {
    final row = await db.query('tasks', where: 'id = ?', whereArgs: [id]);
    if (row.isEmpty) {
      throw TaskNotFoundException(id);
    }
    // ... actualizar
  } catch (e) {
    if (e is AppException) rethrow;
    throw AppException('Error al actualizar');
  }
}

// ✅ Bien: Capturar y manejar en Provider
void _handleError(dynamic e) {
  if (e is AppException) {
    _error = e.toString(); // Mensaje ya en español
  } else {
    _error = 'Error inesperado. Por favor, inténtalo de nuevo.';
  }
  AppLogger.error('Error en Provider', e);
  notifyListeners();
}
```

**Patrones Comunes de Uso**:
- **Validación → Excepción específica**: Validar datos antes de operación, lanzar `TaskValidationException` si falla
- **No encontrado → TaskNotFoundException**: Cuando un recurso no existe (tarea, usuario, etc.)
- **Error de BD → AppException**: Envolver errores técnicos de BD en `AppException` con mensaje amigable
- **Re-lanzar excepciones**: Usar `if (e is AppException) rethrow;` para preservar excepciones personalizadas
- **Logging antes de lanzar**: Usar `AppLogger.error()` para errores técnicos antes de envolver en `AppException`

### 7. Estructura de Validaciones (si aplica)

Si se implementan validaciones:

```
lib/
└── utils/
    └── task_validator.dart  # Validadores específicos
```

- Centralizar validaciones por dominio
- Retornar resultados claros (`ValidationResult`)
- Mensajes de error en español

### 8. Ejemplo Completo de Implementación

**Escenario**: Agregar campo "prioridad" a las tareas (módulo `tasks`)

1. **Modelo** (`models/tasks/task.dart`):
   - Agregar campo `priority` (final int)
   - Actualizar `toMap()` / `fromMap()`

2. **Servicio** (`services/tasks/task_service.dart`):
   - Actualizar schema SQL si es necesario
   - Verificar que create/update manejen el nuevo campo

3. **Provider** (`providers/tasks/task_provider.dart`):
   - Si hay lógica adicional, agregarla aquí

4. **UI** (`screens/tasks/task_detail_screen.dart`):
   - Agregar campo de entrada para prioridad
   - Validar si es necesario

5. **Widgets** (si aplica):
   - Si se muestra prioridad en múltiples lugares, crear `widgets/tasks/priority_badge.dart`

## Resumen de Prioridades

1. **Simplicidad** sobre complejidad
2. **Claridad** sobre optimización prematura
3. **Consistencia** sobre innovación innecesaria
4. **Correctitud** (sin errores, sin warnings) sobre velocidad
5. **Mantenibilidad** (código pequeño y claro) sobre abstracción

## 9. Utilidades del Sistema

El proyecto cuenta con utilidades centralizadas que deben usarse consistentemente:

### 9.1. AppLogger (`lib/utils/logger.dart`)

**Propósito**: Logging centralizado para toda la aplicación.

**Uso**:
- **Siempre usar `AppLogger`** en lugar de `print()` o `debugPrint()` directamente
- Usar `AppLogger.info()` para mensajes informativos
- Usar `AppLogger.error()` para errores (con objeto opcional)
- Usar `AppLogger.debug()` para información de debug (opcional)

**Dónde usar**:
- En servicios: loggear errores de operaciones críticas
- En providers: loggear errores antes de exponerlos al UI
- En operaciones de base de datos: loggear inicialización y errores
- Evitar logging excesivo, solo donde realmente aporte valor

```dart
// ✅ Bien: Uso estratégico
AppLogger.info('Cargando tareas del usuario');
AppLogger.error('Error al guardar tarea', e);

// ❌ Evitar: Logging innecesario
AppLogger.debug('Variable x = $x'); // Solo si realmente es necesario
```

### 9.2. DatabaseIO (`lib/utils/database_io.dart`)

**Propósito**: Manejo centralizado de conexión a base de datos SQLite para mobile/desktop.

**Funcionalidad**:
- **Ubicación del archivo**: Se determina automáticamente por `getDatabasesPath()` de sqflite
- **Conexión singleton**: Mantiene una instancia única durante la vida de la app
- **Inicialización explícita**: Debe llamarse `initializeDatabase()` durante el arranque (ej: `SplashScreen`)
- **Manejo de plataformas**: Desktop (FFI) y móvil (sqflite estándar)
- **Solo para IO**: No usar en web (usar `DatabaseWeb`)

**Uso**:
- **Siempre usar `DatabaseIO.withDatabase()`** para operaciones de BD
- El desarrollador NO necesita manejar apertura/cierre manualmente
- El método `withDatabase()` facilita las operaciones y maneja errores básicos

**Dónde usar**:
- En servicios que acceden a SQLite (principalmente `task_service_io.dart`, `user_service_io.dart`)
- NO usar en servicios web (usar `DatabaseWeb` y SharedPreferences directamente)
- NO cerrar conexión manualmente durante operaciones normales

```dart
// ✅ Bien: Usar withDatabase
Future<List<Task>> loadTasks() async {
  return await DatabaseIO.withDatabase((db) async {
    final res = await db.query('tasks');
    return res.map((r) => Task.fromMap(r)).toList();
  });
}

// ❌ Evitar: Manejo manual de conexión
final db = await DatabaseIO.getDatabase();
// ... operaciones manuales
await db.close(); // NO necesario en operaciones normales
```

**Cierre de conexión**:
- Solo usar `DatabaseIO.closeDatabase()` explícitamente cuando la app se cierra o en casos muy específicos
- Para operaciones normales, NO cerrar la conexión (se mantiene singleton)

### 9.3. DatabaseWeb (`lib/utils/database_web.dart`)

**Propósito**: Inicialización de SharedPreferences para web.

**Funcionalidad**:
- Inicializa SharedPreferences y crea usuario admin por defecto si no existe
- Solo funciona en web (retorna `true` sin hacer nada en mobile/desktop)
- Debe llamarse `initializeDatabase()` durante el arranque (ej: `SplashScreen`)

**Uso**:
- Llamar `DatabaseWeb.initializeDatabase()` durante la inicialización de la app
- Los servicios web acceden directamente a SharedPreferences (no a través de DatabaseWeb)

### 9.4. PlatformHelper (`lib/utils/platform_helper.dart`)

**Propósito**: Centralizar verificaciones de plataforma.

**Funcionalidad**:
- Proporciona getters estáticos para verificar plataforma: `isWeb`, `isMobile`, `isDesktop`, `isMobileOrDesktop`
- Abstraye las verificaciones de `kIsWeb` y `Platform.is*`

**Uso**:
- Usar `PlatformHelper.isWeb` en lugar de `kIsWeb`
- Usar `PlatformHelper.isMobile` o `PlatformHelper.isDesktop` en lugar de verificaciones directas de `Platform`
- Evitar proliferar verificaciones de plataforma en múltiples archivos

```dart
// ✅ Bien: Usar PlatformHelper
if (PlatformHelper.isWeb) {
  await DatabaseWeb.initializeDatabase();
} else {
  await DatabaseIO.initializeDatabase();
}

// ❌ Evitar: Verificaciones directas dispersas
if (kIsWeb) { ... }
if (Platform.isAndroid) { ... }
```

### 9.5. Creación de Nuevas Utilidades

**Directiva**: Si se identifica necesidad de una nueva utilidad (ej: manejo de fechas, formateadores, etc.):

1. **Consultar al usuario primero**: Puede implicar agregar nuevas dependencias al `pubspec.yaml`
2. **Ubicación**: Crear en `lib/utils/` o subdirectorio específico si agrupa múltiples utilidades relacionadas
3. **Ejemplo**: Si se necesita manejo de fechas complejo, crear `lib/utils/date_formatter.dart` solo después de aprobación del usuario (utilidades individuales van directamente en `lib/utils/`, subdirectorios solo si agrupan múltiples utilidades relacionadas)
4. **Evitar**: Crear utilidades sin consultar, especialmente si requieren nuevas librerías

**Ejemplo de consulta necesaria**:
```
"Se identifica necesidad de formateo de fechas complejo. ¿Deseas agregar 
una utilidad DateFormatter? Esto podría requerir la librería intl."
```

## Recordatorios Finales

- Esta es una aplicación **sencilla**, no necesita arquitectura compleja
- **SRP** es importante, pero no exagerar con SOLID completo
- **Widgets pequeños** facilitan mantenimiento
- **Sin tests automatizados**, confiar en testing manual
- **Linting estricto** mantiene calidad
- **Logging centralizado** facilita debugging
- **Conexión BD centralizada** simplifica desarrollo
